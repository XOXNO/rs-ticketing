// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct ManagerProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for ManagerProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = ManagerProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        ManagerProxyMethods { wrapped_tx: tx }
    }
}

pub struct ManagerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> ManagerProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
        Arg5: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        fees: Arg0,
        sc: Arg1,
        register_fees: Arg2,
        signer: Arg3,
        accumulator_sc: Arg4,
        aggregator_sc: Arg5,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&fees)
            .argument(&sc)
            .argument(&register_fees)
            .argument(&signer)
            .argument(&accumulator_sc)
            .argument(&aggregator_sc)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> ManagerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        aggregator_sc: Arg0,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .argument(&aggregator_sc)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> ManagerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade_creator<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        tag: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("upgradeCreator")
            .argument(&tag)
            .original_result()
    }

    pub fn listing<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg6: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg7: ProxyArg<usize>,
        Arg8: ProxyArg<u32>,
        Arg9: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg10: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg11: ProxyArg<bool>,
        Arg12: ProxyArg<bool>,
        Arg13: ProxyArg<bool>,
        Arg14: ProxyArg<bool>,
        Arg15: ProxyArg<bool>,
        Arg16: ProxyArg<bool>,
        Arg17: ProxyArg<bool>,
    >(
        self,
        tag: Arg0,
        cid: Arg1,
        tags: Arg2,
        base_nft_name: Arg3,
        royalties: Arg4,
        token_name: Arg5,
        token_ticker: Arg6,
        collection_size: Arg7,
        global_max_per_wallet: Arg8,
        collectiontag: Arg9,
        nft_ending: Arg10,
        name_shuffle: Arg11,
        has_attributes: Arg12,
        has_kyc: Arg13,
        refund_policy: Arg14,
        public_burn: Arg15,
        bot_protection: Arg16,
        has_reveal: Arg17,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("listing")
            .argument(&tag)
            .argument(&cid)
            .argument(&tags)
            .argument(&base_nft_name)
            .argument(&royalties)
            .argument(&token_name)
            .argument(&token_ticker)
            .argument(&collection_size)
            .argument(&global_max_per_wallet)
            .argument(&collectiontag)
            .argument(&nft_ending)
            .argument(&name_shuffle)
            .argument(&has_attributes)
            .argument(&has_kyc)
            .argument(&refund_policy)
            .argument(&public_burn)
            .argument(&bot_protection)
            .argument(&has_reveal)
            .original_result()
    }

    pub fn listing_for<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg7: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg8: ProxyArg<usize>,
        Arg9: ProxyArg<u32>,
        Arg10: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg11: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg12: ProxyArg<bool>,
        Arg13: ProxyArg<bool>,
        Arg14: ProxyArg<bool>,
        Arg15: ProxyArg<bool>,
        Arg16: ProxyArg<bool>,
        Arg17: ProxyArg<bool>,
        Arg18: ProxyArg<bool>,
        Arg19: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        tag: Arg0,
        user: Arg1,
        cid: Arg2,
        tags: Arg3,
        base_nft_name: Arg4,
        royalties: Arg5,
        token_name: Arg6,
        token_ticker: Arg7,
        collection_size: Arg8,
        global_max_per_wallet: Arg9,
        collectiontag: Arg10,
        nft_ending: Arg11,
        name_shuffle: Arg12,
        has_attributes: Arg13,
        has_kyc: Arg14,
        refund_policy: Arg15,
        public_burn: Arg16,
        bot_protection: Arg17,
        has_reveal: Arg18,
        fees: Arg19,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listingFor")
            .argument(&tag)
            .argument(&user)
            .argument(&cid)
            .argument(&tags)
            .argument(&base_nft_name)
            .argument(&royalties)
            .argument(&token_name)
            .argument(&token_ticker)
            .argument(&collection_size)
            .argument(&global_max_per_wallet)
            .argument(&collectiontag)
            .argument(&nft_ending)
            .argument(&name_shuffle)
            .argument(&has_attributes)
            .argument(&has_kyc)
            .argument(&refund_policy)
            .argument(&public_burn)
            .argument(&bot_protection)
            .argument(&has_reveal)
            .argument(&fees)
            .original_result()
    }

    pub fn register<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        tag: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .raw_call("register")
            .argument(&tag)
            .original_result()
    }

    pub fn register_for<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        tag: Arg0,
        user: Arg1,
        fees: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("registerFor")
            .argument(&tag)
            .argument(&user)
            .argument(&fees)
            .original_result()
    }

    pub fn forward_revenue(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("deposit")
            .original_result()
    }

    pub fn set_child_cut<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        contract: Arg0,
        fees: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("changeChildFees")
            .argument(&contract)
            .argument(&fees)
            .original_result()
    }

    pub fn buy_for<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<usize>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
        Arg5: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg6: ProxyArg<OptionalValue<ManagedBuffer<Env::Api>>>,
        Arg7: ProxyArg<OptionalValue<ManagedBuffer<Env::Api>>>,
    >(
        self,
        contract: Arg0,
        col_tag: Arg1,
        stage_name: Arg2,
        quantity: Arg3,
        user: Arg4,
        twispay: Arg5,
        signature: Arg6,
        data: Arg7,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("mintFor")
            .argument(&contract)
            .argument(&col_tag)
            .argument(&stage_name)
            .argument(&quantity)
            .argument(&user)
            .argument(&twispay)
            .argument(&signature)
            .argument(&data)
            .original_result()
    }

    pub fn giveaway_to<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<usize>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
        Arg5: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg6: ProxyArg<OptionalValue<ManagedBuffer<Env::Api>>>,
        Arg7: ProxyArg<OptionalValue<ManagedBuffer<Env::Api>>>,
    >(
        self,
        contract: Arg0,
        col_tag: Arg1,
        stage_name: Arg2,
        quantity: Arg3,
        user: Arg4,
        twispay: Arg5,
        signature: Arg6,
        data: Arg7,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("giveawayTo")
            .argument(&contract)
            .argument(&col_tag)
            .argument(&stage_name)
            .argument(&quantity)
            .argument(&user)
            .argument(&twispay)
            .argument(&signature)
            .argument(&data)
            .original_result()
    }

    pub fn set_stage_status<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<bool>,
    >(
        self,
        col_tag: Arg0,
        tag: Arg1,
        stage: Arg2,
        status: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setChildStageStatus")
            .argument(&col_tag)
            .argument(&tag)
            .argument(&stage)
            .argument(&status)
            .original_result()
    }

    pub fn claim<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>>,
    >(
        self,
        tags: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimDeveloperRewards")
            .argument(&tags)
            .original_result()
    }

    pub fn template_smart_contract(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("templateSmartContract")
            .original_result()
    }

    pub fn user_contract<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("userContract")
            .argument(&user)
            .original_result()
    }

    pub fn user_updated(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("userUpdated")
            .original_result()
    }

    pub fn user_claimed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("userClaimed")
            .original_result()
    }

    pub fn user_by_creator<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("userByCreator")
            .argument(&user)
            .original_result()
    }

    pub fn get_user<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUser")
            .argument(&address)
            .original_result()
    }

    pub fn contracts(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getContracts")
            .original_result()
    }

    pub fn admins(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmins")
            .original_result()
    }

    pub fn users(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUsers")
            .original_result()
    }

    pub fn wallets(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWallets")
            .original_result()
    }

    pub fn is_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isActive")
            .original_result()
    }

    pub fn child_cut(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("childCut")
            .original_result()
    }

    pub fn register_fees(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("registerFees")
            .original_result()
    }

    pub fn signer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("signer")
            .original_result()
    }

    pub fn accumulator_sc(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccumulator")
            .original_result()
    }

    pub fn aggregator_sc(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAggregator")
            .original_result()
    }

    pub fn users_count(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("usersCount")
            .original_result()
    }

    pub fn users_upgraded_count(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("usersUpgradedCount")
            .original_result()
    }

    pub fn get_creators<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        take: Arg0,
        page: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, Creators<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCreators")
            .argument(&take)
            .argument(&page)
            .original_result()
    }

    pub fn get_creator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        wallet: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Creators<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCreator")
            .argument(&wallet)
            .original_result()
    }

    pub fn is_child_sc<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        wallet: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isChildSC")
            .argument(&wallet)
            .original_result()
    }

    pub fn is_registered<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        tag: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isTagRegistered")
            .argument(&tag)
            .original_result()
    }

    pub fn get_creator_by_tag<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        tag: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Creators<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCreatorByTag")
            .argument(&tag)
            .original_result()
    }

    pub fn set_active<
        Arg0: ProxyArg<bool>,
    >(
        self,
        active: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setActive")
            .argument(&active)
            .original_result()
    }

    pub fn set_cut<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        cut: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCutFees")
            .argument(&cut)
            .original_result()
    }

    pub fn set_register_fees<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        fees: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRegistrationFees")
            .argument(&fees)
            .original_result()
    }

    pub fn set_sc<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        sc: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTemplateSC")
            .argument(&sc)
            .original_result()
    }

    pub fn change_owner<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        old_wallet: Arg0,
        new_wallet: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("changeChildOwner")
            .argument(&old_wallet)
            .argument(&new_wallet)
            .original_result()
    }

    pub fn set_accumulator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        accumulator: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAccumulatorSC")
            .argument(&accumulator)
            .original_result()
    }

    pub fn clear_upgrade<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>>,
    >(
        self,
        tags: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("clearUpgradedUsers")
            .argument(&tags)
            .original_result()
    }

    pub fn clear_claimed<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>>,
    >(
        self,
        tags: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("clearClaimedUsers")
            .argument(&tags)
            .original_result()
    }

    pub fn claim_royalties(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claim_royalties")
            .original_result()
    }

    pub fn claim_esdt<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, u64>>,
    >(
        self,
        token: Arg0,
        nonces: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimESDT")
            .argument(&token)
            .argument(&nonces)
            .original_result()
    }

    pub fn add_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAdmin")
            .argument(&admin)
            .original_result()
    }

    pub fn remove_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAdmin")
            .argument(&admin)
            .original_result()
    }
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq)]
pub struct Creators<Api>
where
    Api: ManagedTypeApi,
{
    pub name: ManagedBuffer<Api>,
    pub contract: ManagedAddress<Api>,
}
