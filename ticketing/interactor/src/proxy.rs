// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct TicketingProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for TicketingProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = TicketingProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        TicketingProxyMethods { wrapped_tx: tx }
    }
}

pub struct TicketingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> TicketingProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        fees: Arg0,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&fees)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> TicketingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> TicketingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn buy<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<usize>,
        Arg4: ProxyArg<OptionalValue<ManagedBuffer<Env::Api>>>,
        Arg5: ProxyArg<OptionalValue<ManagedBuffer<Env::Api>>>,
        Arg6: ProxyArg<OptionalValue<ManagedVec<Env::Api, AggregatorStep<Env::Api>>>>,
        Arg7: ProxyArg<OptionalValue<ManagedVec<Env::Api, TokenAmount<Env::Api>>>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        ticket_stage_id: Arg2,
        quantity: Arg3,
        signature: Arg4,
        data: Arg5,
        swaps: Arg6,
        limits: Arg7,
    ) -> TxTypedCall<Env, From, To, (), Gas, ManagedVec<Env::Api, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("buyTicket")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .argument(&quantity)
            .argument(&signature)
            .argument(&data)
            .argument(&swaps)
            .argument(&limits)
            .original_result()
    }

    pub fn giveaway<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, usize>>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        users: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("issueFreeTicket")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&users)
            .original_result()
    }

    pub fn giveaway_admin<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<usize>,
        Arg5: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg6: ProxyArg<OptionalValue<ManagedBuffer<Env::Api>>>,
        Arg7: ProxyArg<OptionalValue<ManagedBuffer<Env::Api>>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        ticket_stage_id: Arg2,
        to: Arg3,
        quantity: Arg4,
        external_id: Arg5,
        signature: Arg6,
        data: Arg7,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("issuePaidTicket")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .argument(&to)
            .argument(&quantity)
            .argument(&external_id)
            .argument(&signature)
            .argument(&data)
            .original_result()
    }

    pub fn trading_control<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        event_id: Arg0,
        address: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("tradingControl")
            .argument(&event_id)
            .argument(&address)
            .original_result()
    }

    pub fn set_cut_fees<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        fees: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setFees")
            .argument(&fees)
            .original_result()
    }

    pub fn events(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllEvents")
            .original_result()
    }

    pub fn event_by_id<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Event<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEvent")
            .argument(&event_id)
            .original_result()
    }

    pub fn ticket_types<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedBuffer<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllTicketTypes")
            .argument(&event_id)
            .original_result()
    }

    pub fn ticket_type_by_id<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TicketType<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTicketType")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .original_result()
    }

    pub fn ticket_stages<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedBuffer<Env::Api>, TicketStage<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTicketStages")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .original_result()
    }

    pub fn whitelist_wallets<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        ticket_stage_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllowedUsers")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .original_result()
    }

    pub fn buys_per_event<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        user: Arg0,
        event_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("buysPerEvent")
            .argument(&user)
            .argument(&event_id)
            .original_result()
    }

    pub fn buys_per_ticket_type<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        user: Arg0,
        event_id: Arg1,
        ticket_type_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("buysPerTicketType")
            .argument(&user)
            .argument(&event_id)
            .argument(&ticket_type_id)
            .original_result()
    }

    pub fn buys_per_ticket_stage<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        user: Arg0,
        event_id: Arg1,
        ticket_type_id: Arg2,
        ticket_stage_id: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("buysPerTicketStage")
            .argument(&user)
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .original_result()
    }

    pub fn next_nonce<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        ticker: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNonce")
            .argument(&ticker)
            .original_result()
    }

    pub fn collections(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("collections")
            .original_result()
    }

    pub fn token_manager<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenByEventId")
            .argument(&event_id)
            .original_result()
    }

    pub fn transfer_wallets<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTransferWallets")
            .argument(&event_id)
            .original_result()
    }

    pub fn fees(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFees")
            .original_result()
    }

    pub fn income(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getIncome")
            .original_result()
    }

    pub fn is_whitelisted<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        ticket_stage_id: Arg2,
        address: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isWhitelisted")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .argument(&address)
            .original_result()
    }

    pub fn get_events(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, Event<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEvents")
            .original_result()
    }

    pub fn get_types<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TicketType<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTypes")
            .argument(&event_id)
            .original_result()
    }

    pub fn get_type_stages<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TicketStage<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTypeStages")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .original_result()
    }

    pub fn get_all_stages<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TicketStage<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllStages")
            .argument(&event_id)
            .original_result()
    }

    pub fn get_all_income_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllIncomeTokens")
            .original_result()
    }

    pub fn get_all_income_payments<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getIncomePayment")
            .argument(&token)
            .original_result()
    }

    pub fn whitelisted_size<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        ticket_stage_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("whitelistSize")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .original_result()
    }

    pub fn create_event<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<EventArgs>,
    >(
        self,
        event_id: Arg0,
        token_name: Arg1,
        token_ticker: Arg2,
        args: Arg3,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("createEvent")
            .argument(&event_id)
            .argument(&token_name)
            .argument(&token_ticker)
            .argument(&args)
            .original_result()
    }

    pub fn create_ticket_type<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<TicketTypeArgs<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        args: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createTicketType")
            .argument(&event_id)
            .argument(&args)
            .original_result()
    }

    pub fn create_ticket_stage<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<TicketStageArgs<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        args: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createTicketStage")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&args)
            .original_result()
    }

    pub fn remove_ticket_type<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeTicketType")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .original_result()
    }

    pub fn remove_ticket_stage<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        ticket_stage_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeTicketStage")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .original_result()
    }

    pub fn edit_ticket_type<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<TicketTypeArgs<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        args: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editTicketType")
            .argument(&event_id)
            .argument(&args)
            .original_result()
    }

    pub fn edit_ticket_stage<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<TicketStageArgs<Env::Api>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        args: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editTicketStage")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&args)
            .original_result()
    }

    pub fn edit_event<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<EventArgs>,
    >(
        self,
        event_id: Arg0,
        args: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editEvent")
            .argument(&event_id)
            .argument(&args)
            .original_result()
    }

    pub fn add_to_whitelist<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        ticket_stage_id: Arg2,
        wallets: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addWhitelists")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .argument(&wallets)
            .original_result()
    }

    pub fn remove_from_whitelist<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        event_id: Arg0,
        ticket_type_id: Arg1,
        ticket_stage_id: Arg2,
        wallets: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeWhitelists")
            .argument(&event_id)
            .argument(&ticket_type_id)
            .argument(&ticket_stage_id)
            .argument(&wallets)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, ManagedVecItem)]
pub struct AggregatorStep<Api>
where
    Api: ManagedTypeApi,
{
    pub token_in: TokenIdentifier<Api>,
    pub token_out: TokenIdentifier<Api>,
    pub amount_in: BigUint<Api>,
    pub pool_address: ManagedAddress<Api>,
    pub function_name: ManagedBuffer<Api>,
    pub arguments: ManagedVec<Api, ManagedBuffer<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, ManagedVecItem)]
pub struct TokenAmount<Api>
where
    Api: ManagedTypeApi,
{
    pub token: TokenIdentifier<Api>,
    pub amount: BigUint<Api>,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct Event<Api>
where
    Api: ManagedTypeApi,
{
    pub token: TokenIdentifier<Api>,
    pub transfer_role: bool,
    pub id: ManagedBuffer<Api>,
    pub max_capacity: u32,
    pub max_per_user: u32,
    pub fees: BigUint<Api>,
    pub mint_count: u32,
    pub has_kyc: bool,
    pub refund_policy: bool,
    pub append_number: bool,
    pub bot_protection: bool,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct TicketStage<Api>
where
    Api: ManagedTypeApi,
{
    pub prices: ManagedVec<Api, EsdtTokenPayment<Api>>,
    pub id: ManagedBuffer<Api>,
    pub ticket_type_id: ManagedBuffer<Api>,
    pub has_whitelist: bool,
    pub max_per_user: u32,
    pub mint_limit: u32,
    pub mint_count: u32,
    pub start_time: u64,
    pub end_time: u64,
    pub active: bool,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct TicketType<Api>
where
    Api: ManagedTypeApi,
{
    pub base_name: ManagedBuffer<Api>,
    pub image: ManagedBuffer<Api>,
    pub royalties: BigUint<Api>,
    pub id: ManagedBuffer<Api>,
    pub max_per_user: u32,
    pub mint_limit: u32,
    pub mint_count: u32,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct EventArgs {
    pub max_capacity: u32,
    pub max_per_user: u32,
    pub has_kyc: bool,
    pub refund_policy: bool,
    pub append_number: bool,
    pub bot_protection: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct TicketTypeArgs<Api>
where
    Api: ManagedTypeApi,
{
    pub base_name: ManagedBuffer<Api>,
    pub image: ManagedBuffer<Api>,
    pub royalties: BigUint<Api>,
    pub id: ManagedBuffer<Api>,
    pub max_per_user: u32,
    pub mint_limit: u32,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct TicketStageArgs<Api>
where
    Api: ManagedTypeApi,
{
    pub prices: ManagedVec<Api, EsdtTokenPayment<Api>>,
    pub id: ManagedBuffer<Api>,
    pub has_whitelist: bool,
    pub max_per_user: u32,
    pub mint_limit: u32,
    pub start_time: u64,
    pub end_time: u64,
    pub active: bool,
}
